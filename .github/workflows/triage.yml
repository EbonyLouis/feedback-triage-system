name: Issue Triage with goose

on:
  issues:
    types: [opened, reopened]

permissions:
  issues: write
  contents: read

env:
  OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
  GOOSE_PROVIDER: openrouter
  GOOSE_MODEL: anthropic/claude-sonnet-4.5
  GH_TOKEN: ${{ github.token }}

jobs:
  triage:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install goose CLI
        run: |
          mkdir -p /home/runner/.local/bin
          curl -fsSL https://github.com/block/goose/releases/download/stable/download_cli.sh \
            | CONFIGURE=false GOOSE_BIN_DIR=/home/runner/.local/bin bash
          echo "/home/runner/.local/bin" >> $GITHUB_PATH

      - name: Configure goose for OpenRouter
        run: |
          mkdir -p ~/.config/goose
          cat << 'EOF' > ~/.config/goose/config.yaml
          GOOSE_PROVIDER: "openrouter"
          GOOSE_MODEL: "anthropic/claude-sonnet-4.5"
          keyring: false

          extensions:
            developer:
              bundled: true
              enabled: true
              name: developer
              timeout: 300
              type: builtin
          EOF

      - name: Build triage instructions for goose
        env:
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          cat > instructions.txt << EOF
          You are an issue triage assistant for a Winter Festival feedback tracker.

          Read the issue title and body and decide:
          - category: one of "URGENT", "SUGGESTION", "QUESTION", "COMPLAINT", or "PRAISE"
          - priority: one of "HIGH", "MEDIUM", or "LOW"
          - sentiment: one of "positive", "negative", or "neutral"
          - labels: an array of GitHub label names
          - response: a short, friendly Markdown comment for the issue author.

          IMPORTANT:
          - "labels" MUST ONLY contain labels from this list:
            ["urgent", "question", "suggestion", "complaint", "praise"]
          - Do NOT invent new label names outside of that list.
          - Use "urgent" for safety / time-sensitive operational issues
          - Use "question" for people asking where/when/how
          - Use "suggestion" for new ideas / nice-to-have features
          - Use "complaint" for negative feedback that isn't an immediate safety risk
          - Use "praise" for positive feedback / compliments
          - sentiment:
              * "positive" for praise or happy tone
              * "negative" for complaints, broken things, or upset tone
              * "neutral" for straightforward questions or factual reports

          Return ONLY a single JSON object, with no backticks, code fences, or extra text.
          Use this schema exactly:
          {
            "category": "string",
            "priority": "string",
            "sentiment": "string",
            "labels": ["string"],
            "response": "string"
          }

          Title:
          ${ISSUE_TITLE}

          Body:
          ${ISSUE_BODY}
          EOF

      - name: Run goose triage
        run: |
          goose run --no-session -i instructions.txt \
            | sed -E 's/\x1B\[[0-9;]*[mK]//g' \
            > goose_output.txt

      - name: Apply labels and comment from goose output
        env:
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          python - "$ISSUE_NUMBER" << 'PY'
          import json, re, subprocess, sys

          issue_number = sys.argv[1]

          text = open("goose_output.txt", "r", encoding="utf-8").read()
          match = re.search(r'\{.*\}', text, re.S)
          if not match:
              print("No JSON found in goose output:")
              print(text)
              raise SystemExit(1)

          data = json.loads(match.group(0))

          raw_labels = data.get("labels", []) or []
          priority = (data.get("priority") or "MEDIUM").upper()
          sentiment = (data.get("sentiment") or "neutral").lower()
          response = (data.get("response") or "").strip()

          # Only allow labels from this controlled set
          allowed_labels = {
              "urgent",
              "question",
              "suggestion",
              "complaint",
              "praise",
          }
          labels = [l for l in raw_labels if isinstance(l, str) and l in allowed_labels]

          priority_label = f"priority:{priority.lower()}"
          sentiment_label = f"sentiment:{sentiment}"

          print(f"LLM labels (raw): {raw_labels}")
          print(f"Filtered labels: {labels}")
          print(f"Priority: {priority}")
          print(f"Sentiment: {sentiment}")

          # Helper: check + create label if needed
          def ensure_label_exists(label, color="ededed"):
              try:
                  check = subprocess.run(
                      ["gh", "label", "view", label],
                      stdout=subprocess.PIPE,
                      stderr=subprocess.PIPE,
                  )
                  if check.returncode != 0:
                      print(f"Label '{label}' not found â€” creating it.")
                      subprocess.run(
                          ["gh", "label", "create", label, "--color", color],
                          check=True
                      )
              except Exception as e:
                  print(f"Warning: Could not create label '{label}': {e}")

          # Optional: color map for labels
          label_colors = {
              "urgent": "d73a4a",              # red
              "question": "0e8a16",            # green
              "suggestion": "0366d6",          # blue
              "complaint": "d876e3",           # purple
              "praise": "f9d0c4",              # peach
              "priority:high": "b60205",
              "priority:medium": "f9d0c4",
              "priority:low": "c0e1ff",
              "sentiment:positive": "0e8a16",
              "sentiment:neutral": "c5c5c5",
              "sentiment:negative": "d73a4a",
          }

          # Ensure all needed labels exist
          all_needed = labels + [priority_label, sentiment_label]
          for label in all_needed:
              ensure_label_exists(label, label_colors.get(label, "ededed"))

          # Apply festival labels
          for label in labels:
              if not label:
                  continue
              try:
                  subprocess.run(
                      ["gh", "issue", "edit", issue_number, "--add-label", label],
                      check=True,
                  )
              except subprocess.CalledProcessError as e:
                  print(f"Warning: failed to add label '{label}': {e}")

          # Add priority label
          try:
              subprocess.run(
                  ["gh", "issue", "edit", issue_number, "--add-label", priority_label],
                  check=True,
              )
          except subprocess.CalledProcessError as e:
              print(f"Warning: failed to add priority label '{priority_label}': {e}")

          # Add sentiment label
          try:
              subprocess.run(
                  ["gh", "issue", "edit", issue_number, "--add-label", sentiment_label],
                  check=True,
              )
          except subprocess.CalledProcessError as e:
              print(f"Warning: failed to add sentiment label '{sentiment_label}': {e}")

          # Add triage comment
          if response:
              try:
                  subprocess.run(
                      ["gh", "issue", "comment", issue_number, "--body", response],
                      check=True,
                  )
              except subprocess.CalledProcessError as e:
                  print(f"Warning: failed to add comment: {e}")

          print(f"Issue #{issue_number} triaged with goose.")
          PY
